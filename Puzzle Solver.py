# -*- coding: utf-8 -*-
"""20L-1174.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JaASWK7jn75VsF33p79tMaoE3kqa88Ni
"""

import time 

# function to print board
def print_b(board):
    print('|{}|{}|{}|'.format(board[0], board[1], board[2]))
    print('|{}|{}|{}|'.format(board[3], board[4], board[5]))
    print('|{}|{}|{}|'.format(board[6], board[7], board[8]))
     

# function to get adjacent states of current state
def get_adjacent_states(state):
    adjacent_states = []
    i = state.index(0)
    if i not in [0, 1, 2]:
        new_state = state[:]
        new_state[i], new_state[i-3] = new_state[i-3], new_state[i]
        adjacent_states.append(new_state)
    if i not in [0, 3, 6]:
        new_state = state[:]
        new_state[i], new_state[i-1] = new_state[i-1], new_state[i]
        adjacent_states.append(new_state)
    if i not in [6, 7, 8]:
        new_state = state[:]
        new_state[i], new_state[i+3] = new_state[i+3], new_state[i]
        adjacent_states.append(new_state)
    if i not in [2, 5, 8]:
        new_state = state[:]
        new_state[i], new_state[i+1] = new_state[i+1], new_state[i]
        adjacent_states.append(new_state)
    return adjacent_states 

# function to implement DFS algorithm
def dfs(start_state, goal_):
    start_time = time.time()
    depth_limit = 1
    stack = [(start_state, [start_state], 0)]
    nodes_visited = 1
    while stack:
        current_state, path, path_cost = stack.pop()
        if current_state == goal_:
            end_time = time.time()
            print('DFS Algorithm:')
            
            print('Time :'.format(end_time - start_time))
            print('Path Cost:'.format(path_cost))
            print('No of Node Visited: {}'.format(nodes_visited))
          
            for p in path:
                print_b(p)
                
            return path
        for adjacent_state in get_adjacent_states(current_state):
            if adjacent_state not in path:
                nodes_visited += 1
                stack.append((adjacent_state, path + [adjacent_state], path_cost+1))
    depth_limit += 1

# function to implement BFS algorithm
def bfs(start_state, goal_):
    start_time = time.time()
    queue = [(start_state, [start_state], 0)]
    nodes_visited = 1
    while queue:
        current_state, path, path_cost = queue.pop(0)
        if current_state == goal_:
            end_time = time.time()
            
            print('BFS Algorithm')
            print('Time : '.format(end_time - start_time))
            print('Path Cost: '.format(path_cost))
            print('No of Node Visited: '.format(nodes_visited))
            
            for p in path:
                print_b(p)
            return path
        for adjacent_state in get_adjacent_states(current_state):
            if adjacent_state not in [p for _, p, _ in queue]:
                nodes_visited += 1
                queue.append((adjacent_state, path + [adjacent_state], path_cost+1))

def ids(start_state, goal_):
    start_time = time.time()
    depth_limit = 1
    nodes_visited = 0
    while True:
        stack = [(start_state, [start_state], 0)]
        nodes_visited += 1
        while stack:
            current_state, path, path_cost = stack.pop()
            if current_state == goal_:
                end_time = time.time()
                print('IDS Algorithm')
               
                print('Time :  '.format(end_time - start_time))
                print('Path Cost: '.format(path_cost))
                print('No of Node Visited:'.format(nodes_visited))
                for p in path:
                    print_b(p)
                    print('-----')
                return path
            if path_cost < depth_limit:
                for adjacent_state in get_adjacent_states(current_state):
                    if adjacent_state not in path:
                        nodes_visited += 1
                        stack.append((adjacent_state, path + [adjacent_state], path_cost+1))
        depth_limit += 1

if __name__ == 'main':
    start_ = input('Enter start State: ')
    start_ = [int(i) for i in start_]
    goal_ = input('Enter goal State: ')
    goal_ = [int(i) for i in goal_]
    dfs(start_, goal_)
    bfs(start_, goal_)
    ids(start_, goal_)